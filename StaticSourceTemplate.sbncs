# nullable enable
// <auto-generated/>
using System;
using Godot;
using System.Collections.Generic;
using System.Linq;
using MongoDB.Bson;

namespace HLNC.Serialization
{
    public static partial class NetworkScenesRegister
    {
        private static Dictionary<byte, string> SCENES_MAP = new Dictionary<byte, string>(){
            {{ for scene in ScenesMap }}
                { {{scene.Key}}, "{{scene.Value}}" },
            {{ end }}
        };

        private static Dictionary<string, byte> SCENES_PACK = new Dictionary<string, byte>(){
            {{ for scene in ScenesMap }}
                { "{{scene.Value}}", {{scene.Key}} },
            {{ end }}
        };

        /// <summary>
        /// A map of every packed scene to a list of paths to its internal network nodes.
        /// </summary>
        private static Dictionary<string, Dictionary<byte, string>> STATIC_NETWORK_NODE_PATHS_MAP = new Dictionary<string, Dictionary<byte, string>>(){
            {{ for scene in StaticNetworkNodesMap }}
                { "{{scene.Key}}", new Dictionary<byte, string>(){
                    {{ for node in scene.Value }}
                        { {{node.Item1}}, "{{node.Item2}}" },
                    {{ end }}
                } },
            {{ end }}
        };

        private static Dictionary<string, Dictionary<string, byte>> STATIC_NETWORK_NODE_PATHS_PACK = new Dictionary<string, Dictionary<string, byte>>(){
            {{ for scene in StaticNetworkNodesMap }}
                { "{{scene.Key}}", new Dictionary<string, byte>(){
                    {{ for node in scene.Value }}
                        { "{{node.Item2}}", {{node.Item1}} },
                    {{ end }}
                } },
            {{ end }}
        };

        private static Dictionary<string, Dictionary<string, Dictionary<string, CollectedNetworkProperty>>> PROPERTIES_MAP = new Dictionary<string, Dictionary<string, Dictionary<string, CollectedNetworkProperty>>>(){
            {{ for scene in PropertiesMap }}
                {
                    "{{scene.Key}}", new Dictionary<string, Dictionary<string, CollectedNetworkProperty>>() {
                        {{ for node in scene.Value }}
                            {
                                "{{node.Key}}", new Dictionary<string, CollectedNetworkProperty>() {
                                    {{ for property in node.Value }}
                                        { "{{property.Key}}", new CollectedNetworkProperty{
                                                NodePath = "{{node.Key}}",
                                                Name = "{{property.Value.Name}}",
                                                Type = (Variant.Type){{property.Value.Type}},
                                                Subtype = (HLNC.Serialization.VariantSubtype){{property.Value.Subtype}},
                                                Index = {{property.Value.Index}},
                                                InterestMask = {{property.Value.InterestMask}},
                                                {{ if property.Value.NetworkSerializerClass != "" }}
                                                NetworkSerialize = Callable.From((WorldRunner currentWorld, NetPeer peer, {{property.Value.NetworkSerializerClass}} obj) =>
                                                {
                                                    return {{property.Value.NetworkSerializerClass}}.NetworkSerialize(currentWorld, peer, obj) as HLBuffer;
                                                }),
                                                NetworkDeserialize = Callable.From((WorldRunner currentWorld, HLBuffer buffer, {{property.Value.NetworkSerializerClass}} obj) =>
                                                {
                                                    return {{property.Value.NetworkSerializerClass}}.NetworkDeserialize(currentWorld, buffer, obj);
                                                }),
                                                {{ end }}
                                                {{ if property.Value.BsonSerializerClass != "" }}
                                                BsonDeserialize = (BsonValue doc) =>
                                                {
                                                    return {{property.Value.BsonSerializerClass}}.BsonDeserialize(doc);
                                                },
                                                {{ end }}
                                            }
                                        },
                                    {{ end }}
                                }
                            },
                        {{ end }}
                    }
                },
            {{ end }}
        };

        private static Dictionary<string, Dictionary<string, Dictionary<string, CollectedNetworkFunction>>> FUNCTIONS_MAP = new Dictionary<string, Dictionary<string, Dictionary<string, CollectedNetworkFunction>>>(){
            {{ for scene in FunctionsMap }}
                {
                    "{{scene.Key}}", new Dictionary<string, Dictionary<string, CollectedNetworkFunction>>() {
                        {{ for node in scene.Value }}
                            {
                                "{{node.Key}}", new Dictionary<string, CollectedNetworkFunction>() {
                                    {{ for function in node.Value }}
                                        { "{{function.Key}}", new CollectedNetworkFunction{
                                                NodePath = "{{node.Key}}",
                                                Name = "{{function.Value.Name}}",
                                                Index = {{function.Value.Index}},
                                                Arguments = [
                                                    {{ for arg in function.Value.Arguments }}
                                                    new VariantType{
                                                        Type = Variant.Type.{{arg.Type}},
                                                        Subtype = VariantSubtype.{{arg.Subtype}},
                                                    },
                                                    {{ end }}
                                                ],
                                                WithPeer = {{function.Value.WithPeer}},
                                            }
                                        },
                                    {{ end }}
                                }
                            },
                        {{ end }}
                    }
                },
            {{ end }}
        };

        private static Dictionary<string, Dictionary<byte, CollectedNetworkFunction>> FUNCTIONS_LOOKUP = new Dictionary<string, Dictionary<byte, CollectedNetworkFunction>>(){
            {{ for scene in FunctionsMap }}
                {
                    "{{scene.Key}}", new Dictionary<byte, CollectedNetworkFunction>() {
                        {{ for node in scene.Value }}
                            {{ for function in node.Value }}
                                { {{function.Value.Index}}, FUNCTIONS_MAP["{{scene.Key}}"]["{{node.Key}}"]["{{function.Key}}"] },
                            {{ end }}
                        {{ end }}
                    }
                },
            {{ end }}
        };

        private static Dictionary<string, Dictionary<byte, CollectedNetworkProperty>> PROPERTIES_LOOKUP = new Dictionary<string, Dictionary<byte, CollectedNetworkProperty>>(){
            {{ for scene in PropertiesMap }}
                {
                    "{{scene.Key}}", new Dictionary<byte, CollectedNetworkProperty>() {
                        {{ for node in scene.Value }}
                            {{ for property in node.Value }}
                                { {{property.Value.Index}}, PROPERTIES_MAP["{{scene.Key}}"]["{{node.Key}}"]["{{property.Key}}"] },
                            {{ end }}
                        {{ end }}
                    }
                },
            {{ end }}
        };

        private static Dictionary<byte, PackedScene> SCENES_CACHE = [];

        public static byte PackScene(string scene) {
            return SCENES_PACK[scene];
        }

        public static PackedScene UnpackScene(byte sceneId) {
            if (!SCENES_CACHE.ContainsKey(sceneId)) {
                SCENES_CACHE[sceneId] = GD.Load<PackedScene>(SCENES_MAP[sceneId]);
            } 
            return SCENES_CACHE[sceneId];
        }

        public static bool LookupProperty(string scene, string node, string property, out CollectedNetworkProperty prop) {
            if (!PROPERTIES_MAP.ContainsKey(scene) || !PROPERTIES_MAP[scene].ContainsKey(node) || !PROPERTIES_MAP[scene][node].ContainsKey(property)) {
                prop = new CollectedNetworkProperty();
                return false;
            }

            prop = PROPERTIES_MAP[scene][node][property];
            return true;
        }

        public static List<Tuple<string, List<CollectedNetworkProperty>>> ListProperties(string scene) {
            if (!PROPERTIES_MAP.ContainsKey(scene)) {
                return new List<Tuple<string, List<CollectedNetworkProperty>>>();
            }

            var result = new List<Tuple<string, List<CollectedNetworkProperty>>>();
            foreach (var node in PROPERTIES_MAP[scene]) {
                result.Add(new Tuple<string, List<CollectedNetworkProperty>>(node.Key, new List<CollectedNetworkProperty>(node.Value.Values)));
            }
            return result;
        }

        public static CollectedNetworkProperty UnpackProperty(string scene, byte propertyId) {
            return PROPERTIES_LOOKUP[scene][propertyId];
        }

        public static string UnpackNode(string scene, byte nodeId) {
            return STATIC_NETWORK_NODE_PATHS_MAP[scene][nodeId];
        }

        public static bool PackNode(string scene, string node, out byte nodeId) {
            if (!STATIC_NETWORK_NODE_PATHS_PACK.ContainsKey(scene) || !STATIC_NETWORK_NODE_PATHS_PACK[scene].ContainsKey(node)) {
                nodeId = 0;
                return false;
            }

            nodeId = STATIC_NETWORK_NODE_PATHS_PACK[scene][node];
            return true;
        }

        public static List<NetworkNodeWrapper> ListNetworkChildren(Node node) { 
            return NetworkScenesRegister.STATIC_NETWORK_NODE_PATHS_MAP[node.SceneFilePath].Aggregate(new List<NetworkNodeWrapper>(), (acc, path) => {
                var child = node.GetNodeOrNull(path.Value);
                if (child != null) {
                    acc.Add(new NetworkNodeWrapper(child));
                }
                return acc;
            });
        }

        public static bool LookupFunction(string scene, string node, string function, out CollectedNetworkFunction func) {
            if (!FUNCTIONS_MAP.ContainsKey(scene) || !FUNCTIONS_MAP[scene].ContainsKey(node) || !FUNCTIONS_MAP[scene][node].ContainsKey(function)) {
                func = new CollectedNetworkFunction();
                return false;
            }

            func = FUNCTIONS_MAP[scene][node][function];
            return true;
        }

        public static CollectedNetworkFunction UnpackFunction(string scene, byte functionId) {
            return FUNCTIONS_LOOKUP[scene][functionId];
        }
    }
}